/** =========================================================================
 * Google Apps Script — Backend for 5-FU app
 * - No created_at / updated_at columns at all
 * - Dates persisted as DD/MM/YYYY in both sheets (Assessments, PhoneLogs)
 * - saveAssessment_ does MERGE (partial update) by 'id' (doesn't erase other cols)
 * - PhoneLogs includes 'name' column; call_time stored as DD/MM/YYYY
 * - NEW: deletePhoneLog_ deletes a single PhoneLogs row by log_id (with optional id/call_time)
 * ========================================================================= */

const SETTINGS = {
  SHEET_ASSESS: 'Assessments',
  SHEET_PHONE:  'PhoneLogs',

  // أعمدة Assessments (بدون created/updated)
  ASSESS_COLUMNS: [
    'id','assessment_date','name','phone','sex','age','regimen','cycle','stage','diagnosis',
    'toxicity_found','toxicity',
    'mucositis_grade','diarrhea_grade','neutropenia_grade',
    'other_tox_name','other_tox_grade',
    // تبقى dpyd_* لكن تُحدَّث فقط من Phone Assessment (أول مرة)
    'dpyd_present','dpyd_type',
    'followup_due',
    'hospitalization_due_tox','delay','stop','dose_modification','dose_reduction_pct',
    'first_date_5fu',
    'notes',
  ],

  // أعمدة PhoneLogs (بدون created/updated) + name
  PHONE_COLUMNS: [
    'log_id',
    'id',
    'name',
    'call_time',              // DD/MM/YYYY
    'diarrhea',
    'mucositis',
    'neutropenia',
    'fever',
    'chest',
    'neuro',
    'hospitalization',
    'hospitalization_due_tox',
    'delay',
    'stop',
    'dose_modification',
    'dose_reduction_pct',
    'other_tox_name',
    'other_tox_grade',
    'dpyd_present',
    'dpyd_type',
    'weight_change',
    'next_due',               // DD/MM/YYYY
    'notes',
  ],
};

/* ==========================
 * Helpers
 * ========================== */
function _ss(){ return SpreadsheetApp.getActiveSpreadsheet(); }
function _getSheet(name){ const ss=_ss(); return ss.getSheetByName(name)||ss.insertSheet(name); }

function _getHeader(sh){
  const lastCol = sh.getLastColumn();
  if (lastCol < 1) return [];
  // نرجّع العناوين بعد trim
  return (sh.getRange(1, 1, 1, lastCol).getValues()[0] || []).map(v => String(v||'').trim());
}
function _setHeader(sh, headers){
  if (!headers || !headers.length) return;
  sh.getRange(1, 1, 1, headers.length).setValues([headers]);
}
function _ensureColumns(sh, desired){
  const current = _getHeader(sh);
  if (!current.length){
    if (desired && desired.length) _setHeader(sh, desired.slice());
    return desired ? desired.slice() : [];
  }
  const set = new Set(current.filter(Boolean));
  const add = [];
  (desired||[]).forEach(h => { if (!set.has(h)) { set.add(h); add.push(h); } });
  if (add.length){ _setHeader(sh, current.concat(add)); }
  return _getHeader(sh);
}
function _indexOfHeader(headers,name){
  name=String(name||'').trim();
  for (let i=0;i<headers.length;i++){ if(headers[i]===name) return i; }
  return -1;
}

function _expandHeadersForObject(sh, obj, preferred){
  let headers = _ensureColumns(sh, preferred || []);
  const extras = Object.keys(obj||{}).filter(k => headers.indexOf(k) === -1);
  if (extras.length){ headers = _ensureColumns(sh, headers.concat(extras)); }
  return headers;
}

// ===== Patch: قراءة تتحمّل تكرار أسماء الأعمدة (نأخذ أول ظهور فقط)
function _readRowObject(sh, rowIndex){
  const headers = _getHeader(sh);
  if (rowIndex < 2) return {};
  const vals = sh.getRange(rowIndex, 1, 1, headers.length).getValues()[0] || [];
  const obj = {};
  headers.forEach((h,i)=>{
    if (!(h in obj)) { obj[h] = vals[i]; } // أول ظهور فقط
  });
  return obj;
}

// ===== Patch: كتابة تتحمّل تكرار أسماء الأعمدة (نملأ أول عمود فقط لكل اسم)
function _writeRowObject(sh, rowIndex, obj){
  const headers = _getHeader(sh);
  const seen = new Set();
  const row = headers.map(h => {
    const key = String(h);
    if (seen.has(key)) return '';           // تجاهل الأعمدة المكررة
    seen.add(key);
    return (Object.prototype.hasOwnProperty.call(obj, key) ? obj[key] : '');
  });
  if (rowIndex === -1){ sh.appendRow(row); return sh.getLastRow(); }
  sh.getRange(rowIndex, 1, 1, headers.length).setValues([row]); return rowIndex;
}

function _findRowIndexByKey(sh, keyName, keyValue){
  const headers = _getHeader(sh);
  const colIdx = _indexOfHeader(headers, keyName);
  if (colIdx === -1) return -1;
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return -1;
  const col = sh.getRange(2, colIdx+1, lastRow-1).getValues().map(r=>r[0]);
  for (let i=0;i<col.length;i++){
    if (String(col[i]) === String(keyValue)) return i+2;
  }
  return -1;
}
function _deleteRowsWhere(sh, predicate){
  const headers = _getHeader(sh);
  const lastRow = sh.getLastRow();
  if (!headers.length || lastRow < 2) return 0;
  const values = sh.getRange(2, 1, lastRow-1, headers.length).getValues();
  const rowsToDelete = [];
  values.forEach((arr,i)=>{
    const obj = {};
    headers.forEach((h,j)=>{
      if (!(h in obj)) obj[h]=arr[j]; // أول ظهور فقط
    });
    if (predicate(obj)) rowsToDelete.push(i+2);
  });
  for (let k=rowsToDelete.length-1;k>=0;k--){ sh.deleteRow(rowsToDelete[k]); }
  return rowsToDelete.length;
}

/* ==========================
 * Date formatting (DD/MM/YYYY)
 * ========================== */
function _pad(n){ return ('0'+n).slice(-2); }
function _toDMY(dateLike){
  // يقبل ISO الكامل أو YYYY-MM-DD أو Date أو نص قابل للتحويل -> DD/MM/YYYY
  if (!dateLike) return '';
  let d;
  if (dateLike instanceof Date) d = dateLike;
  else if (typeof dateLike === 'string' && /^\d{4}-\d{2}-\d{2}([T\s].*)?$/i.test(dateLike.trim())) d = new Date(dateLike);
  else d = new Date(dateLike);
  if (isNaN(d)) return String(dateLike);
  return _pad(d.getDate())+'/'+_pad(d.getMonth()+1)+'/'+d.getFullYear();
}

/* ==========================
 * Assessments
 * ========================== */
function listAssessments_(){
  const sh = _getSheet(SETTINGS.SHEET_ASSESS);
  _ensureColumns(sh, SETTINGS.ASSESS_COLUMNS);
  // نُرجع كما هو مخزون (تواريخ مخزّنة DD/MM/YYYY)
  const headers = _getHeader(sh);
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return [];
  const rng = sh.getRange(2,1,lastRow-1,headers.length);
  const vals = rng.getValues();
  return vals.map(r => {
    const o = {};
    headers.forEach((h,i)=>{ if (!(h in o)) o[h]=r[i]; });
    return o;
  });
}

/** MERGE save by id: لا نلمس أي عمود غير مُرسل */
function saveAssessment_(payload){
  if (!payload || !payload.id) return { ok:false, error:'id is required' };
  const sh = _getSheet(SETTINGS.SHEET_ASSESS);
  _ensureColumns(sh, SETTINGS.ASSESS_COLUMNS);
  _expandHeadersForObject(sh, payload, SETTINGS.ASSESS_COLUMNS);

  // جهّز نسخ DD/MM/YYYY لحقول التاريخ إن وُجدت
  const p = Object.assign({}, payload);
  if (p.assessment_date) p.assessment_date = _toDMY(p.assessment_date);
  if (p.followup_due)    p.followup_due    = _toDMY(p.followup_due);

  // 1st date 5FU — إن وُجد نحوله، وإن لم يوجد نضع تاريخ اليوم
  if (p.first_date_5fu)  p.first_date_5fu  = _toDMY(p.first_date_5fu);
  if (!p.first_date_5fu) p.first_date_5fu  = _toDMY(new Date());

  const rowIndex = _findRowIndexByKey(sh, 'id', p.id);
  if (rowIndex === -1){
    // INSERT — صف جديد، نملأ فقط المُرسل
    const base = {}; _getHeader(sh).forEach(h => base[h]='');
    const merged = Object.assign(base, p);
    _writeRowObject(sh, -1, merged);
    return { ok:true, action:'insert' };
  } else {
    // UPDATE — دمج مع القيم الحالية
    const current = _readRowObject(sh, rowIndex);
    const merged  = Object.assign({}, current, p);
    _writeRowObject(sh, rowIndex, merged);
    return { ok:true, action:'update' };
  }
}

/* ==========================
 * Phone Logs
 * ========================== */
function listPhoneLogs_(idOpt){
  const sh = _getSheet(SETTINGS.SHEET_PHONE);
  _ensureColumns(sh, SETTINGS.PHONE_COLUMNS);
  const headers = _getHeader(sh);
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return [];
  const rng = sh.getRange(2,1,lastRow-1,headers.length);
  const vals = rng.getValues();
  const all = vals.map(r => {
    const o = {}; headers.forEach((h,i)=>{ if (!(h in o)) o[h]=r[i]; }); return o;
  });
  if (!idOpt) return all;
  return all.filter(r => String(r.id||'') === String(idOpt));
}

function savePhoneLog_(payload){
  if (!payload || !payload.id) return { ok:false, error:'id is required' };

  const sh = _getSheet(SETTINGS.SHEET_PHONE);
  _ensureColumns(sh, SETTINGS.PHONE_COLUMNS);
  _expandHeadersForObject(sh, payload, SETTINGS.PHONE_COLUMNS);

  const p = Object.assign({}, payload);

  // call_time -> DD/MM/YYYY
  p.call_time = _toDMY(p.call_time || new Date());

  // next_due (اختياري): حوّله لو موجود
  if (p.next_due) p.next_due = _toDMY(p.next_due);

  // تأكد من وجود log_id
  if (!p.log_id) p.log_id = 'log_' + Utilities.getUuid();

  const rowIndex = _findRowIndexByKey(sh, 'log_id', p.log_id);

  if (rowIndex === -1){
    const base = {}; _getHeader(sh).forEach(h => base[h]='');
    const merged = Object.assign(base, p);
    _writeRowObject(sh, -1, merged);
    return { ok:true, action:'insert' };
  } else {
    const current = _readRowObject(sh, rowIndex);
    const merged  = Object.assign({}, current, p);
    _writeRowObject(sh, rowIndex, merged);
    return { ok:true, action:'update' };
  }
}

/** NEW: Delete a single phone log by log_id (with optional id/call_time verification) */
function deletePhoneLog_(payload){
  var id        = String((payload && payload.id) || '');
  var log_id    = String((payload && payload.log_id) || '');
  var call_time = String((payload && payload.call_time) || '');

  if (!log_id) return { ok:false, error:'missing_log_id' };

  // طبيع call_time إلى DD/MM/YYYY لو أُرسل
  if (call_time) call_time = _toDMY(call_time);

  var sh = _getSheet(SETTINGS.SHEET_PHONE);
  _ensureColumns(sh, SETTINGS.PHONE_COLUMNS);
  var headers = _getHeader(sh);
  var lastRow = sh.getLastRow();
  if (lastRow < 2) return { ok:false, error:'empty_sheet' };

  var idxLog  = _indexOfHeader(headers, 'log_id');
  var idxId   = _indexOfHeader(headers, 'id');
  var idxTime = _indexOfHeader(headers, 'call_time');

  if (idxLog === -1) return { ok:false, error:'missing_log_id_column' };

  var values = sh.getRange(2, 1, lastRow-1, headers.length).getValues();
  var rowIndexToDelete = -1; // 1-based
  for (var i=0; i<values.length; i++){
    var row = values[i];
    var matchLog  = String(row[idxLog]) === log_id;
    var matchId   = (idxId  === -1 || !id)        ? true : (String(row[idxId])  === id);
    var matchTime = (idxTime=== -1 || !call_time) ? true : (String(row[idxTime])=== call_time);
    if (matchLog && matchId && matchTime){
      rowIndexToDelete = i + 2; // header = row 1
      break;
    }
  }

  if (rowIndexToDelete === -1) return { ok:false, error:'not_found' };

  sh.deleteRow(rowIndexToDelete);
  return { ok:true, deleted_row: rowIndexToDelete, log_id: log_id };
}

/* ==========================
 * Delete (Cascade)
 * ========================== */
function deleteAssessmentCascade_(id){
  if (!id) return { ok:false, error:'id is required' };
  const assess = _getSheet(SETTINGS.SHEET_ASSESS);
  const phone  = _getSheet(SETTINGS.SHEET_PHONE);
  _ensureColumns(assess, SETTINGS.ASSESS_COLUMNS);
  _ensureColumns(phone,  SETTINGS.PHONE_COLUMNS);

  let aDel = 0;
  const rowIdx = _findRowIndexByKey(assess, 'id', id);
  if (rowIdx > -1){ assess.deleteRow(rowIdx); aDel = 1; }

  const pDel = _deleteRowsWhere(phone, obj => String(obj.id||'') === String(id));
  return { ok:true, deleted_assessment:aDel, deleted_phone_logs:pDel };
}

/* ==========================
 * HTTP endpoints
 * ========================== */
function _respondJson(obj, cb){
  const out = JSON.stringify(obj);
  if (cb){
    return ContentService.createTextOutput(`${cb}(${out})`).setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return ContentService.createTextOutput(out).setMimeType(ContentService.MimeType.JSON);
}
function _safeDecodeBase64ToJson(b64){
  if (!b64) return {};
  try {
    const txt = Utilities.newBlob(Utilities.base64Decode(b64)).getDataAsString();
    return JSON.parse(txt);
  } catch(e){ return {}; }
}

function doGet(e){
  try{
    const p = e && e.parameter ? e.parameter : {};
    const action = String(p.action||'');
    const cb = String(p.callback||'');
    const dataParam = p.data || '';
    const payload = dataParam ? _safeDecodeBase64ToJson(dataParam) : {};

    let result;
    if (action==='listAssessments')               result = listAssessments_();
    else if (action==='saveAssessment')           result = saveAssessment_(payload);
    else if (action==='deleteAssessmentCascade')  result = deleteAssessmentCascade_(String(p.id||'')); 
    else if (action==='listPhoneLogs')            result = listPhoneLogs_(String(p.id||'')||null);
    else if (action==='savePhoneLog')             result = savePhoneLog_(payload);
    else if (action==='deletePhoneLog')           result = deletePhoneLog_(payload);           // NEW
    else                                          result = { ok:false, error:'Unknown action' };

    return _respondJson(result, cb);
  }catch(err){
    const cb = e && e.parameter && e.parameter.callback;
    return _respondJson({ ok:false, error:String(err) }, cb);
  }
}

function doPost(e){
  try{
    const p = e && e.parameter ? e.parameter : {};
    const action = String(p.action||'');
    const body = e && e.postData && e.postData.contents ? JSON.parse(e.postData.contents) : {};

    let result;
    if (action==='saveAssessment')               result = saveAssessment_((body||{}));
    else if (action==='deleteAssessmentCascade') result = deleteAssessmentCascade_(body && body.id);
    else if (action==='savePhoneLog')            result = savePhoneLog_(body||{});
    else if (action==='listAssessments')         result = listAssessments_();
    else if (action==='listPhoneLogs')           result = listPhoneLogs_(body && body.id);
    else if (action==='deletePhoneLog')          result = deletePhoneLog_(body||{});          // NEW
    else                                         result = { ok:false, error:'Unknown action' };

    return _respondJson(result, null);
  }catch(err){
    return _respondJson({ ok:false, error:String(err) }, null);
  }
}
